@using BlazorUI.Client
@using System.Diagnostics
@using Microsoft.JSInterop.Implementation
@inject IJSRuntime JS
@inherits LayoutComponentBase

<div class="page" @onkeydown=@Pressed @onkeyup=@Released tabindex="0">
    <div class="sprites" style="height: 0px; overflow:hidden;">
        @foreach (var bmp in bitmaps)
        {
            var bmpId = bmp;
            <img id="@bmpId" @ref="@bmpRefs[bmpId]"/>
        }
        @foreach (var cv in canvases)
        {
            var bmpId = cv.Item1;
            var width = cv.Item2;
            var height = cv.Item3;
            <BECanvas Width=width Height=height @ref="@cvRefs[bmpId]"></BECanvas>
        }
    </div>
    <div class="gamePanel" style="@style">
        <BECanvas Width=@width Height=@height @ref=canvas></BECanvas>
    </div>
</div>


@code
{
    public static MainLayout Instance;
    private Canvas2DContext _context;
    BECanvasComponent canvas;
    List<string> bitmaps = new List<string>();
    Dictionary<string, ElementReference> bmpRefs = new Dictionary<string, ElementReference>();
    List<(string, int, int)> canvases = new List<(string, int, int)>();
    Dictionary<string, BECanvasComponent> cvRefs = new Dictionary<string, BECanvasComponent>();
    int width = 1;
    int height = 1;
    double scale = 1;
    string style = "";

    public delegate void KeyEvent(KeyboardEventArgs args);

    public KeyEvent keyPress;
    public KeyEvent keyRelease;

    public void Pressed(KeyboardEventArgs args)
    {
        keyPress(args);
    }

    public void Released(KeyboardEventArgs args)
    {
        keyRelease(args);
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        style = $"position: relative; left: calc(50% - {width / 2}px); top: calc(50% - {height / 2}px); width: {width}px; height: {height}px;";
        Instance = this;
    }

    public void HookKeyboard(KeyEvent press, KeyEvent release)
    {
        this.keyPress += press;
        this.keyRelease += release;
    }

    public static async Task WaitInitialized()
    {
        while (Instance == null)
        {
            await Task.Delay(TimeSpan.FromMilliseconds(10));
        }
    }

    public async Task SetDesktopScaling(BlazorPanel panel)
    {
        panel.DesktopScaling = await JS.InvokeAsync<double>("Utils.getPixelRatio");
    }

    public void SetBounds(int w, int h, double sw, double sh)
    {
        Task.Run(async () =>
        {
            double devicePixelRatio = await JS.InvokeAsync<double>("Utils.getPixelRatio");
            width = (int)(w);
            height = (int)(h);
            style = $"position: relative; left: calc(50% - {width / 2}px); top: calc(50% - {height / 2}px); width: {width}px; height: {height}px;";
            
            await Task.Delay(TimeSpan.FromMilliseconds(100));

            await JS.InvokeVoidAsync("Utils.disableSmoothing");
        });
    }

    int x = 0;
    Stopwatch sw = new Stopwatch();
    public async Task Draw(BlazorPanel panel, Drawer2DBlazor drawer)
    {
        await this._context.ClearRectAsync(0, 0, width, height);
        await this._context.SetFillStyleAsync("white");
        await this._context.SetStrokeStyleAsync("white");
        await this._context.StrokeRectAsync(0, 0, width, height);


        try
        {
            await this._context.StrokeTextAsync($"{x}", 4, 16);
            await drawer.Draw(panel, this._context);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
            throw;
        }

        await this._context.StrokeTextAsync($"{x}", 4, 16);
        x++;

        if (sw.ElapsedTicks >= Stopwatch.Frequency)
        {
            x = 0;
            sw.Restart();
        }
    }

    public async Task<BECanvasComponent> AddBitmap(string name, int width, int height)
    {
        if (bitmaps.Contains(name))
        {
            return cvRefs[name];
        }

        canvases.Add((name, width, height));
        this.StateHasChanged();

        while (!cvRefs.ContainsKey(name))
        {
            await Task.Delay(TimeSpan.FromMilliseconds(10));
        }

        await Task.Delay(TimeSpan.FromMilliseconds(10));

        return cvRefs[name];
    }

    public async Task<ElementReference> AddBitmap(string name, DotNetStreamReference stream)
    {
        if (bitmaps.Contains(name))
        {
            return bmpRefs[name];
        }

        bitmaps.Add(name);
        this.StateHasChanged();

        try
        {
            while (!bmpRefs.ContainsKey(name))
            {
                await Task.Delay(TimeSpan.FromMilliseconds(10));
            }

            await Task.Delay(TimeSpan.FromMilliseconds(10));

            try
            {
                await JS.InvokeVoidAsync("Utils.setImage", name, stream);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
                throw;
            }

            return bmpRefs[name];
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
            throw;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (firstRender)
        {
            this._context = await this.canvas.CreateCanvas2DAsync();
            BlazorWindow.Instance.Init(this);
            sw.Start();
        }
    }
}